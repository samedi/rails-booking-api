# frozen_string_literal: true

# Base abstract class for form object models generated by {CommentFormModelBuilder}.
#
# @abstract
class CommentFormBase
  include ActiveModel::Model
  include ActiveModel::Attributes

  LABEL_TEXT_LAMBDA = lambda { |label, required, _explicit_label|
    ActionController::Base.helpers.safe_join([label, required&.html_safe].compact, ' ')
  }

  TYPE_SPECIFIC_FIELD_OPTIONS = {
    'textarea' => { as: :text }.freeze,
    'date' => { as: :date, html5: true }.freeze,
    'time' => { as: :time, html5: true }.freeze,
    'duration' => { as: :time, html5: true }.freeze,
    'checkbox' => {
      as: :radio_buttons,
      collection: [[I18n.t(:option_yes), true].freeze, [I18n.t(:option_no), false].freeze].freeze
    }.freeze,
    'combo' => ->(config) { { as: config.multi? ? :check_boxes : :select, collection: config.values } }
  }.freeze

  def self.model_name
    ActiveModel::Name.new(self, nil, 'CommentForm')
  end

  # Register a mapping from an attribute name to a comment form field.
  #
  # This map is necessary so that we could get the appropriate types when building a form or serializing the values.
  #
  # @param attribute [String] Normalized attribute name.
  # @param to [CommentFormField] Matching comment form field.
  def self.map(attribute:, to:)
    @map ||= {}
    @map[attribute] = to
  end

  # Finds a field by the attribute name.
  #
  # @param attr_name [String] Normalized attribute name.
  # @return [CommentFormField] Matching comment form field.
  def self.fetch_comment_field(attr_name)
    @map.fetch(attr_name)
  end

  # Prepares a hash that represents the values of the comment form prepared for
  # submitting to the Booking API.
  #
  # @return [Hash<String, Object>] A hash with keys that contain comment field names. The values are serialized
  #   for Booking API. Currently only fields of type combo that allow multiple selection have a special
  #   serialization (joined by commas).
  def to_hash
    attributes.map { |attribute, value|
      field = self.class.fetch_comment_field(attribute)
      value = serialize_value_api(field, value)

      [field.name, value]
    }.to_h
  end

  # Specifies options for generating a form field in the view.
  #
  # Using the mapping provided by {.map} it maps an attribute by its name to a type understood by SimpleForm.
  #
  # @param attr_name [String] Normalized attribute name.
  # @return [Hash] Options that can be passed to SimpleForm's `#input` helper.
  def simple_form_field_options(attr_name)
    comment_field = self.class.fetch_comment_field(attr_name)

    {
      label: comment_field.name,
      label_text: LABEL_TEXT_LAMBDA
    }.merge(
      type_specific_field_options(comment_field.type, comment_field.config)
    )
  end

  private

  def type_specific_field_options(type, config)
    options = TYPE_SPECIFIC_FIELD_OPTIONS.fetch(type) {
      fallback_options = { as: :string }
      fallback_options[:placeholder] = config.empty_text if config.empty_text.present?
      fallback_options
    }

    if options.respond_to?(:call)
      options.call(config)
    else
      options
    end
  end

  def checkbox_label(comment_field)
    required_html =
      (SimpleForm::Inputs::BooleanInput.translate_required_html if comment_field.required?)

    LABEL_TEXT_LAMBDA.call(comment_field.name, required_html, nil).html_safe
  end

  def serialize_value_api(comment_field, value)
    case comment_field.type
    when 'combo'
      if comment_field.config.multi?
        value.join(', ')
      else
        value
      end
    else value
    end
  end
end
